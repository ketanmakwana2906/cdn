def post(self, request, irctc_path):
        import datetime

        """Wrap POST requests for irctc
        """
        # print"In Post"
        now = datetime.datetime.now()
        original_request = request
        response = {}
        url_path = ""

        # ARP 60 days applicable from 1st Nov 2024 as per irctc guidelines

        q_date = request.data.get('query_date', None)
        if q_date:
            query_date = datetime.datetime.strptime(q_date, "%Y%m%d").date()
            print("query date", query_date)
            print("now.date()", now.date())
            print("datetime.datetime(2024, 11, 1).date()", datetime.datetime(2024, 11, 1).date())
            print("(now.date() + datetime.timedelta(days=63)", (now.date() + datetime.timedelta(days=63)))
            print("now.date() >= datetime.datetime(2024, 11, 1).date()", now.date() >= datetime.datetime(2024, 11, 1).date())
            print("query_date > (now.date() + datetime.timedelta(days=63)", query_date > (now.date() + datetime.timedelta(days=63)))
            if now.date() >= datetime.datetime(2024, 11, 1).date() and query_date > (now.date() + datetime.timedelta(days=63)):
                return JsonResponse({
                    "tm_success": False,
                    "errorMessage": "Nov 1st onwards - Advance Booking Allowed Only for 60 Days.",
                    'success': False,
                    'error': "",
                    'data':[]
                })

        try:
            # added ios because ios is not sending platform in request headers by default
            platform = request.META.get('HTTP_PLATFORM', 'ios')
            version = parse(request.META.get('HTTP_VERSION_NAME', '9.2.7.3'))
            if platform.lower() == 'android' and version <= parse('10.1.6.7'):
                return JsonResponse({
                    "tm_success": False,
                    "errorMessage": "Please update the app to latest version",
                    'success': False,
                    'error': "",
                    'data':[]
                }, safe=False)
            if platform.lower() == 'android' and version <= parse('10.0.1.7'):
                return JsonResponse({
                    "tm_success": False,
                    "errorMessage": "Server Unresponsive, please try later",
                    'success': False,
                    'error': "",
                    'data':[]
                }, safe=False)
        except Exception as e:
            print(str(e))

        try:
            tm_booking_id = None
            bfr_irctc = TASKS.before_irctc(irctc_path, request)
            bfr_irctc_time = datetime.datetime.now()
            print(irctc_path, "bfr_irct time taken: ", (bfr_irctc_time - now))

            if bfr_irctc['skip_irctc']:
                response = bfr_irctc['data']
            else:
                request = bfr_irctc['data']
                request_meta, url_path = self._get_path_and_header(
                    irctc_path, request)
                request.data["masterId"] = USER_NAME
                try:
                    if re.match('.*userregistrationservice/register$', url_path):
                        request.data["copyAddressResToOff"] = "N"
                        # check all required keys must be present
                        all_keys = set(request.data.keys())
                        not_available_keys = list(set(IRCTC_USER_SIGNUP_REQUIRED_KEYS) - all_keys)
                        if not_available_keys:
                            response['tm_success'] = False
                            response['errorMessage'] = '{} not present.'.format(not_available_keys)
                            return JsonResponse(response)

                        # add office and other fields in case it is not available
                        for key, get_value_from_tup in list(IRCTC_USER_SIGNUP_COPY_OFF_FIELDS.items()):
                            if request.data.get(key):
                                continue
                            value = request.data[get_value_from_tup[1]] if get_value_from_tup[0] == "get" else get_value_from_tup[1]
                            request.data[key] = value

                        # set password if it's missing
                        # doing 2 loops because there are only 2 fields in the list
                        if not all([request.data.get(key) for key in IRCTC_USER_SIGNUP_PASSWORD_FIELDS]):
                            password = irctc_generate_pw()
                            for key in IRCTC_USER_SIGNUP_PASSWORD_FIELDS:
                                request.data[key] = password

                    # If quota is SS in avlFareenquiry with passengers request, change to GN
                    if re.match('.*avlFareenquiry.*\/SS\/Y$', url_path):
                        url_path = url_path[:-4]+'GN/Y'
                        # print "URL PATH", url_path

                    # statsd.increment('irctc_hit', tags=url_path.split("/")[5:7])
                    
                    tm_booking_id = request.data.get('tm_booking_id')

                    # irctc_response = requests.post(
                    #     url_path, params=request.query_params, json=request.data, auth=(USER_NAME, PASSWORD), timeout=20)
                    st_time = tmt.time()
                    print('Hitting IRCTC post api', url_path)
                    irctc_response = None
                    n_call_req = False
                    if re.match('.*avlFareenquiry.*\/Y$', url_path):
                        proceded_for_n_call = False
                        service, enq_type, train, url_date, origin, dest, travel_class, quota, api_type = irctc_path.split("/")
                        n_call_url = copy.deepcopy(url_path)
                        if n_call_url[-1] != 'Y':
                            n_call_url = n_call_url[:-1]
                        if n_call_url[-1] != 'Y':
                            print(f"some issue in url path: {url_path}")
                        else:
                            proceded_for_n_call = True
                            print(f"set proceded_for_n_call: {proceded_for_n_call}")
                            n_call_url = n_call_url[:-1]
                            n_call_url = n_call_url + 'N'
                            print(f"set proceded_for_n_call with url: {n_call_url}")
                        data = {
                            "irctc_path": f"{service}/{enq_type}/{train}/{url_date}/{origin}/{dest}/{travel_class}/{quota}/N",
                            "n_call_url": n_call_url,
                            "travel_class": travel_class,
                            "url_date": url_date
                        }
                        if proceded_for_n_call:
                            print(f"hitting N call for url_path: {url_path}")
                            celery_data = {'pickled_data': pickle.dumps(data)}
                            task_id = run_via_celery(hit_n_call_after_y_call_to_update_cache, **celery_data)
                            print(f"hit_n_call_after_y_call_to_update_cache: {task_id}")

                    if re.match('.*avlFareenquiry.*\/N$', url_path):
                        n_call_req = True
                        service, enq_type, train, url_date, origin, dest, travel_class, quota, api_type = irctc_path.split("/")
                        key = f"{train}/{url_date}/{origin}/{dest}/{travel_class}/{quota}/{api_type}".lower()
                        irctc_response = cache.get(key)
                        if irctc_response:
                            print(f"{key} pickle obj found")
                            try:
                                irctc_response = pickle.loads(irctc_response)
                                print(f"{key} cache get")
                            except Exception as e:
                                print(f"{key} cache get issue:{str(e)}")
                                irctc_response = None
                        else:
                            print(f"{irctc_path} pickle obj not found")
                    if not irctc_response:
                        irctc_response = requests.post(url_path, params=request.query_params, json=request.data, timeout=40)
                        try:
                            irctc_response.raise_for_status()
                            resp_json = irctc_response.json()
                            if n_call_req and 'avlDayList' in resp_json:
                                train = resp_json['trainNo']
                                dest = resp_json['to']
                                origin = resp_json['from']
                                travel_class = resp_json['enqClass']
                                quota = resp_json['quota']
                                if isinstance(resp_json['avlDayList'], dict):
                                    url_date = datetime.datetime.strptime(resp_json['avlDayList']['availablityDate'], "%d-%m-%Y").strftime("%Y%m%d")
                                    key = f"{train}/{url_date}/{origin}/{dest}/{travel_class}/{quota}/N".lower()
                                    if quota.lower() == 'tq':
                                        cache.set(key, pickle.dumps(irctc_response), timeout=TQ_N_CALL_CACHE_TIME)
                                    else:
                                        cache.set(key, pickle.dumps(irctc_response), timeout=ALL_N_CALL_CACHE_TIME)
                                    print(f"{key} cache set")
                                elif isinstance(resp_json['avlDayList'], list):
                                    for obj in resp_json['avlDayList'][:1]:
                                        url_date = datetime.datetime.strptime(obj['availablityDate'], "%d-%m-%Y").strftime("%Y%m%d")
                                        key = f"{train}/{url_date}/{origin}/{dest}/{travel_class}/{quota}/N".lower()
                                        if quota.lower() == 'tq':
                                            cache.set(key, pickle.dumps(irctc_response), timeout=TQ_N_CALL_CACHE_TIME)
                                        else:
                                            cache.set(key, pickle.dumps(irctc_response), timeout=ALL_N_CALL_CACHE_TIME)
                                        print(f"{key} cache set")
                        except Exception as e:
                            print("exception in irctc request {} {}".format(irctc_path, str(e)))
                    print('Time taken to hit ', url_path, 'is', tmt.time()-st_time)

                    save_url_count(url_path, "SUCCESS", req_type="POST")
                    irctc_response_time = datetime.datetime.now()
                    print(irctc_path, "irctc_response time taken: ", (irctc_response_time - bfr_irctc_time))
                except Timeout:
                    save_url_count(url_path, "TIMEOUT", req_type="POST")
                    print("IRCTC POST request timeout hit")
                    response['tm_success'] = False
                    response['errorMessage'] = 'IRCTC servers are busy. Please try later.'
                    return JsonResponse(response)
                except Exception as e:
                    save_url_count(url_path, "EXCEPTION", req_type="POST")
                    response['tm_success'] = False
                    response['errorMessage'] = 'IRCTC servers are unresponsive. Please try later.'
                    return JsonResponse(response)

                t1 = datetime.datetime.now()
                print(irctc_path, "after irctc_response time taken: ", (t1 - bfr_irctc_time))

                try:
                    irctc_response = json.loads(irctc_response.text)
                    response = irctc_response

                    # hardcode check for testing ta on web
                    if settings.STAGING_FLAG and response.get('trainNo', '') in ("22918", "12926", "19020", "12280", "11058"):
                        if 'avlDayList' in list(response.keys()):
                            if isinstance(response['avlDayList'], list):
                                for avl in response['avlDayList']:
                                    avl['availablityStatus'] = 'GNWL2/WL1'
                            elif isinstance(response['avlDayList'], dict):
                                response['avlDayList']['availablityStatus'] = 'GNWL2/WL1'

                except Exception as e:
                    save_url_count(url_path, "EXCEPTION", req_type="POST")
                    logger.error("IRCTC response POST: path:{}: exception: {}: response: {}: traceback: {}".format(url_path, str(e), irctc_response.text, traceback.format_exc()))
                    print("Exception ", e)
                    print("IRCTC response POST : ", irctc_response.text)
                    raise

            t1 = datetime.datetime.now()
            print(irctc_path, "json load irctc_response time taken: ", (t1 - bfr_irctc_time))

            if'errorMessage' in response and response['errorMessage']:
                response['tm_success'] = False
                if tm_booking_id:
                    booking = Booking.objects.filter(tm_booking_id=tm_booking_id)
                    if booking.exists():
                        booking = booking.first()
                        booking.error = response['errorMessage']
                        booking.save()
                logger.error("IRCTC response POST: path:{}: errorMessage: {}".format(url_path, response['errorMessage']))
            elif 'tm_success' not in response:
                response = TASKS.after_irctc(irctc_path, request, response)
                if 'tm_success' not in response:
                    response['tm_success'] = True

            t1 = datetime.datetime.now()
            #print(irctc_path, "message load irctc_response time taken: ", (t1 - bfr_irctc_time))

            # if user opted for FCS
            if re.match('.*avlFareenquiry.*\/Y$', url_path) and 'fcs_shown_to_user' in response:
                if not request.user.is_authenticated():
                    raise Exception("user must be authenticated for Y call")
                platform = original_request.data.get('platform', None)
                app_version = parse(original_request.data.get('version', ''))
                if (platform.lower() == 'android' and app_version < parse(FCS_ANDROID_START_VERSION)) or\
                    (platform.lower() in ("ios", "iphone") and app_version < parse(FCS_IOS_START_VERSION)):
                    print(("FCS is not available in platform: {} and version: {}".format(platform, original_request.data.get('version', ''))))
                else:
                    # adding entry in FCS table
                    obj = FCSOpted(
                        user_id=original_request.user.id,
                        tm_booking_id=response['tm_booking_id'],
                        fcs_opted=response['fcs_opted'],
                        number_of_passengers=len(original_request.data.get('passengerList')),
                        fcs_shown_to_user=response['fcs_shown_to_user'],
                        total_ticket_fare=response['totalFare'],
                        fcs_charge_factor=response['fcs_charge_factor'],
                        initial_ticket_status=response['initial_ticket_status'],
                        fcs_mode=response['fcs_mode'],
                        fcs_refund_factor = FCS_PLUS_REFUND_FACTOR if response.get('fcs_mode') and response.get('fcs_mode').lower() == 'plus' else 0.0
                    )
                    obj.save()

            t1 = datetime.datetime.now()
            print(irctc_path, "FCS Opted insertion load irctc_response time taken: ", (t1 - bfr_irctc_time))

            # user opted trip assurance
            if re.match('.*avlFareenquiry.*\/Y$', url_path) and 'ta_opted' in original_request.data:
                if not request.user.is_authenticated():
                    raise Exception("user must be authenticated for Y call")
                # add entry in optins for metrics and all
                try:
                    opt_in = TripAssuranceOptIns(
                        tm_booking_id = response['tm_booking_id'],
                        ta_opted = original_request.data.get('ta_opted'),
                        charge_per_person = original_request.data.get('ta_fee_per_person', 0.0),
                        number_of_passengers = len(original_request.data.get('passengerList')),
                        prediction_perc = original_request.data.get('ta_perc', None),
                        max_charge_per_person = original_request.data.get('ta_max_charge_per_person', 0.0),
                        model_label = original_request.data.get('model_label', '')[:50],
                        mode = original_request.data.get('mode', 'flight')
                    )
                    opt_in.save()
                except Exception as e:
                    print((str(e)))

                # add entry in trip assurance table if TA opted for calculation and all purposes
                if original_request.data.get('ta_opted') and not(response.get('fcs_opted')):
                    obj = TripAssurance(
                        user_id = original_request.user.id,
                        tm_booking_id = response['tm_booking_id'],
                        charge_per_person = original_request.data.get('ta_fee_per_person'),
                        number_of_passengers = len(original_request.data.get('passengerList')),
                        prediction_perc = original_request.data.get('ta_perc'),
                        max_charge_per_person = original_request.data.get('ta_max_charge_per_person', 0.0),
                        model_label = original_request.data.get('model_label', '')[:50],
                        mode = original_request.data.get('mode', 'flight'),
                        original_mode = original_request.data.get('mode', 'flight'),
                        base_fare=response.get('totalFare', 0.0)
                    )
                    obj.save()

                if original_request.data.get('ta_opted') and response.get('fcs_opted'):
                    logger.error("IRCTC response POST: path:{}: exception: {} TM_EXCEPTION".format(
                            url_path, "both fcs and ta can not be opted together")
                    )
                    raise Exception("FCS and TA both cannot be opted at the same time. Please either select FCS or TA.")

            t1 = datetime.datetime.now()
            print(irctc_path, "Extra service load irctc_response time taken: ", (t1 - bfr_irctc_time))

        except Exception as e:
            save_url_count(url_path, "TM_EXCEPTION", req_type="POST")
            traceback.print_exc()
            response['tm_success'] = False
            response['errorMessage'] = "IRCTC servers are unresponsive. Please try later."
            logger.error("IRCTC response POST: path:{}: exception: {}: response: {}: traceback: {} TM_EXCEPTION".format(url_path, str(e), str(response), traceback.format_exc()))
        overall_time = datetime.datetime.now()
        print(irctc_path, "overall time taken: ", (overall_time - now))
        return JsonResponse(response)
